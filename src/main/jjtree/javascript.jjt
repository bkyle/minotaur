
// TODO: Full Unicode Support
options
{
	STATIC = false;
//	UNICODE_INPUT = true;
	DEBUG_PARSER = true;
//	LOOKAHEAD = 3;

	// JJTree Options
//	MULTI = true;
//	TRACK_TOKENS = true;
	NODE_CLASS = "parser.ASTNode";
	VISITOR = true;
//	NODE_SCOPE_HOOK = true;
}

PARSER_BEGIN(JavascriptParser)
package parser;

public class JavascriptParser
{
	JavascriptParser() {
		this.disable_tracing();
	}
	
	public void setTracing(boolean trace) {
		if (trace)
			this.enable_tracing();
		else
			this.disable_tracing();
	}
}

PARSER_END(JavascriptParser)

/*
 * Whitespace
 */
<DEFAULT, IGNORE_REGEX>
SKIP : 
{
	< [ "\t", /*"\v", "\f",*/ " ", "\r", "\n" ] >
}

/*
 * Comments
 */

< DEFAULT, IGNORE_REGEX >
SKIP : 
{
	< "//" (~["\n","\r"])* >
}

< DEFAULT, IGNORE_REGEX >
SKIP :
{
	"/*" : COMMENT
}

< COMMENT >
SKIP :
{
	"*/" : DEFAULT
}

< COMMENT >
SKIP : 
{
	< ~[] >
}

/*
 * Reserved Words
 */

< DEFAULT, IGNORE_REGEX >
TOKEN : 
{
	< ABSTRACT : "abstract" > : DEFAULT |
	< BOOLEAN : "boolean" > : DEFAULT |
	< BREAK : "break" > : DEFAULT |
	< BYTE : "byte" > : DEFAULT |
	< CASE : "case" > : DEFAULT |
	< CATCH : "catch" > : DEFAULT |
	< CHAR : "char" > : DEFAULT |
	< CLASS : "class" > : DEFAULT |
	< CONTINUE : "continue" > : DEFAULT |
	< CONST : "const" > : DEFAULT |
	< DEBUGGER : "debugger" > : DEFAULT |
	< _DEFAULT : "default" > : DEFAULT |
	< DELETE : "delete" > : DEFAULT |
	< DO : "do" > : DEFAULT |
	< DOUBLE : "double" > : DEFAULT |
	< ELSE : "else" > : DEFAULT |
	< ENUM : "enum" > : DEFAULT |
	< EXPORT : "export" > : DEFAULT |
	< EXTENDS : "extends" > : DEFAULT |
	< FALSE : "false" > : DEFAULT |
	< FINAL : "final" > : DEFAULT |
	< FINALLY : "finally" > : DEFAULT |
	< FLOAT : "float" > : DEFAULT |
	< FOR : "for" > : DEFAULT |
	< FUNCTION : "function" > : DEFAULT |
	< GOTO : "goto" > : DEFAULT |
	< IF : "if" > : DEFAULT |
	< IMPLEMENTS : "implements" > : DEFAULT |
	< IN : "in" > : DEFAULT |
	< INSTANCEOF : "instanceof" > : DEFAULT |
	< INT : "int" > : DEFAULT |
	< INTERFACE : "interface" > : DEFAULT |
	< IS : "is" > : DEFAULT |
	< LONG : "long" > : DEFAULT |
	< NATIVE : "native" > : DEFAULT |
	< NEW : "new" > : DEFAULT |
	< NULL : "null" > : DEFAULT |
	< PACKAGE : "package" > : DEFAULT |
	< PRIVATE : "private" > : DEFAULT |
	< PROTECTED : "protected" > : DEFAULT |
	< RETURN : "return" > : DEFAULT |
	< SHORT : "short" > : DEFAULT |
	< STATIC : "static" > : DEFAULT |
	< SUPER : "super" > : DEFAULT |
	< SWITCH : "switch" > : DEFAULT |
	< SYNCHRONIZED : "synchronized" > : DEFAULT |
	< THIS : "this" > : DEFAULT |
	< THROW : "throw" > : DEFAULT |
	< THROWS : "throws" > : DEFAULT |
	< TRANSIENT : "transient" > : DEFAULT |
	< TRUE : "true" > : DEFAULT |
	< TRY : "try" > : DEFAULT |
	< TYPEOF : "typeof" > : DEFAULT |
	< VAR : "var" > : DEFAULT |
	< VOID : "void" > : DEFAULT |
	< VOLATILE : "volatile" > : DEFAULT |
	< WHILE : "while" > : DEFAULT |
	< WITH : "with" > : DEFAULT
}

/*
 * Operators
 */
< DEFAULT, IGNORE_REGEX >
TOKEN :
{
	< DOT : "." > : DEFAULT |
	< PLUS : "+" > : DEFAULT |
	< MINUS : "-" > : DEFAULT |
	< MULT : "*" > : DEFAULT |
	< DIV : "/" > : DEFAULT |
	< MOD : "%" > : DEFAULT |
	< INC : "++" > : DEFAULT |
	< DEC : "--" > : DEFAULT |
	< ASSIGN : "=" > : DEFAULT |
	< PLUS_ASSIGN : "+=" > : DEFAULT |
	< MINUS_ASSIGN : "-=" > : DEFAULT |
	< MULT_ASSIGN : "*=" > : DEFAULT |
	< DIV_ASSIGN : "/=" > : DEFAULT |
	< MOD_ASSIGN : "%=" > : DEFAULT |
	< LSHIFT_ASSIGN : "<<=" > : DEFAULT |
	< RSHIFT_ASSIGN : ">>=" > : DEFAULT |
	< URSHIFT_ASSIGN : ">>>=" > : DEFAULT |
	< BAND_ASSIGN : "&=" > : DEFAULT |
	< BOR_ASSIGN : "|=" > : DEFAULT |
	< XOR_ASSIGN : "^=" > : DEFAULT |
	< EQUAL : "==" > : DEFAULT |
	< EEQUAL : "===" > : DEFAULT |
	< NOT_EQUAL : "!=" > : DEFAULT |
	< NOT_EEQUAL : "!==" > : DEFAULT |
	< LT : "<" > : DEFAULT |
	< GT : ">" > : DEFAULT |
	< LTE : "<=" > : DEFAULT |
	< GTE : ">=" > : DEFAULT |	
	< BAND : "&" > : DEFAULT |
	< AND : "&&" > : DEFAULT |
	< BOR : "|" > : DEFAULT |
	< OR : "||" > : DEFAULT |
	< XOR : "^" > : DEFAULT |
	< BNOT : "~" > : DEFAULT |
	< NOT : "!" > : DEFAULT |
	< LPAREN : "(" > : DEFAULT |
	< RPAREN : ")" > : IGNORE_REGEX |
	< LBRACKET : "[" > : DEFAULT |
	< RBRACKET : "]" > : DEFAULT |
	< LBRACE : "{" > : DEFAULT |
	< RBRACE : "}" > : DEFAULT |
	< QUESTION : "?" > : DEFAULT |
	< COLON : ":" > : DEFAULT |
	< SEMICOLON : ";" > : DEFAULT |
	< LSHIFT : "<<" > : DEFAULT |
	< RSHIFT : ">>" > : DEFAULT |
	< URSHIFT : ">>>" > : DEFAULT |
	< COMMA : "," > : DEFAULT
}

/*
 * Complex Tokens
 */
< DEFAULT, IGNORE_REGEX >
TOKEN :
{

	// Identifiers
	< IDENTIFIER : <IDENTIFIER_START> (<IDENTIFIER_START> | <IDENTIFIER_CHAR>)* > : IGNORE_REGEX |
	< #IDENTIFIER_START : ( [ "$","_","A"-"Z","a"-"z" ] )> |
	< #IDENTIFIER_CHAR : ( [ "$","_","A"-"Z","a"-"z","0"-"9" ] ) > |

	// Numeric Literals
	< DECIMAL_LITERAL : (
		<DECIMAL_INTEGER_LITERAL> <DOT> (<DECIMAL_DIGITS>)? (<EXPONENT_PART>)? | 
		<DOT> <DECIMAL_DIGITS> (<EXPONENT_PART>)? |
		<DECIMAL_INTEGER_LITERAL> (<EXPONENT_PART>)? ) > : DEFAULT |
	
	< #DECIMAL_INTEGER_LITERAL : ( "0" | <NON_ZERO_DIGIT> (<DECIMAL_DIGITS>)? ) > |
	< #DECIMAL_DIGITS : ( <DECIMAL_DIGIT> )+ > |
	< #DECIMAL_DIGIT : ( [ "0"-"9" ] ) > |
	< #NON_ZERO_DIGIT : ( [ "1"-"9" ] ) > |
	< #EXPONENT_PART : ( <EXPONENT_INDICATOR> <SIGNED_INTEGER> ) > |
	< #EXPONENT_INDICATOR : ( "e" | "E" ) > |
	< #SIGNED_INTEGER : ( <DECIMAL_DIGITS> | <PLUS> <DECIMAL_DIGITS> | <MINUS> <DECIMAL_DIGITS> ) > |

	< HEX_INTEGER_LITERAL : ( ( "0x" | "0X") ( <HEX_DIGIT> )+ ) > : DEFAULT |
	< #HEX_DIGIT : ( [ "0"-"9", "a"-"f", "A"-"F" ] ) > |


	// String Literals
	< STRING_LITERAL : ( "\"" <DOUBLE_QUOTED_STRING_CHARS> "\"" | "'" <SINGLE_QUOTED_STRING_CHARS> "'" ) > : DEFAULT |
	< #DOUBLE_QUOTED_STRING_CHARS : ( <DOUBLE_QUOTED_STRING_CHAR> | <ESCAPE_SEQUENCE> )* > |
	< #DOUBLE_QUOTED_STRING_CHAR : ( ~["\\", "\"", "\r", "\n"] ) > |

	< #SINGLE_QUOTED_STRING_CHARS : ( <SINGLE_QUOTED_STRING_CHAR> | <ESCAPE_SEQUENCE> )* > |
	< #SINGLE_QUOTED_STRING_CHAR : ( ~["\\", "'", "\r", "\n"] ) > |

	< #ESCAPE_SEQUENCE : ( "\\" ( <CHARACTER_ESCAPE_SEQUENCE> | <HEX_ESCAPE_SEQUENCE> | <UNICODE_ESCAPE_SEQUENCE> ) ) > |
	< #CHARACTER_ESCAPE_SEQUENCE : ( <SINGLE_ESCAPE_CHARACTER> | <HEX_ESCAPE_SEQUENCE> | <UNICODE_ESCAPE_SEQUENCE> ) > |
	< #SINGLE_ESCAPE_CHARACTER : ["'", "\"", "\\", "b", "f", "n", "r", "t", "v"] > |
	< #HEX_ESCAPE_SEQUENCE : ( "x" <HEX_DIGIT> <HEX_DIGIT> ) > |
	< #UNICODE_ESCAPE_SEQUENCE: ( "u" <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> ) >
}

< DEFAULT >
TOKEN : 
{
	// Regex Literals
	// TODO: Revisit when refactoring lexemes for unicode.
	< REGEX_LITERAL : ("/" <REGEX_BODY> "/" ( <REGEX_FLAGS> )? ) > : DEFAULT |
	< #REGEX_BODY : ( <REGEX_FIRST_CHAR> <REGEX_CHARS> ) > |
	< #REGEX_CHARS : ( <REGEX_CHAR> )* > |
	< #REGEX_FIRST_CHAR : ( ~["\r", "\n", "*", "/", "\\"] | <BACKSLASH_SEQUENCE> ) > |
	< #REGEX_CHAR : ( ~[ "\r", "\n", "/", "\\" ] | <BACKSLASH_SEQUENCE> ) > |
	< #BACKSLASH_SEQUENCE : ("\\" ~[ "\r", "\n"] ) > |
	< #REGEX_FLAGS : ( <IDENTIFIER_CHAR> )* >
}


public void Identifier() : { Token t = null; }
{
	t = <IDENTIFIER>
	{ jjtThis.value = t.image; } 
}


public void Literal() : { }
{
	NullLiteral() | 
	BooleanLiteral() |
	NumericLiteral() |
	StringLiteral() |
	RegExLiteral()
}

public void NullLiteral() : { }
{
	<NULL>
}

public void BooleanLiteral() : { }
{
	<TRUE> { jjtThis.value = "true"; } |
	<FALSE> { jjtThis.value = "false"; }
}

public void NumericLiteral() : { Token t = null; }
{
	(
		t = <DECIMAL_LITERAL> |
		t = <HEX_INTEGER_LITERAL>
	) { jjtThis.value = t.image; }
}

public void StringLiteral() : { Token t = null; }
{
	t = <STRING_LITERAL> { jjtThis.value = t.image; }
}

public void RegExLiteral() : { Token t = null; }
{
	t = <REGEX_LITERAL> { jjtThis.value = t.image; }
}

/*
 * Expressions
 */

public void PrimaryExpression() : { }
{
	<THIS> { jjtThis.value = "this"; } |
	Identifier() |
	Literal() |
	ArrayLiteral() |
	ObjectLiteral() |
	<LPAREN> Expression() <RPAREN>
}

public void ArrayLiteral() : { }
{
	<LBRACKET> (ElementList())? <RBRACKET>
}

public void ElementList() : { }
{
	(Elsion())* AssignmentExpression() ( <COMMA> (Elsion())* AssignmentExpression() )*
}

public void Elsion() : { }
{
	<COMMA>
}

public void ObjectLiteral() : { }
{
	<LBRACE> ( PropertyNameAndValueList() )? <RBRACE>
}

public void PropertyNameAndValueList() : { }
{
	PropertyNameAndValue() ( <COMMA> PropertyNameAndValue() )*
}

public void PropertyNameAndValue() : {}
{
	PropertyName() <COLON> AssignmentExpression()
}

public void PropertyName() : { }
{
	Identifier() |
	StringLiteral() |
	NumericLiteral()
}

public void MemberExpression() : { }
{
	( LOOKAHEAD ( <FUNCTION> ) FunctionExpression() | PrimaryExpression() ) ( LOOKAHEAD( 2 ) MemberExpressionCont() )* |
	NewExpression()	
}

public void MemberExpressionCont() : { }
{
	( <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )
}

public void NewExpression() : { }
{
	<NEW> MemberExpression() ( LOOKAHEAD (2) MemberExpressionCont() )*
}

public void CallExpression() : { }
{
	MemberExpression() Arguments() ( LOOKAHEAD ( 2 ) CallExpressionCont() )*
}

public void CallExpressionCont() : { }
{
	( Arguments() | <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )
}	

public void Arguments() : { }
{
	LOOKAHEAD ( 2 ) <LPAREN> <RPAREN> |
	<LPAREN> ArgumentList() <RPAREN>
}

public void ArgumentList() : { }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void LeftHandSideExpression() : { }
{
	LOOKAHEAD ( CallExpression() ) CallExpression() | 
	MemberExpression()
}

public void PostfixExpression() : { }
{
	LeftHandSideExpression() ( LOOKAHEAD ( 1 ) PostfixOperator() )?
}

public void PostfixOperator() : { Token t = null; }
{
	(
		t = <INC> |
		t = <DEC>
	)
	{ jjtThis.value = t.image; }
}

public void UnaryExpression() : { Token t = null; }
{
	PostfixExpression() |
	(
		(
			t = <DELETE> |
			t = <VOID> |
			t = <TYPEOF> |
			t = <INC> |
			t = <DEC> |
			t = <PLUS> |
			t = <MINUS> |
			t = <BNOT> |
			t = <NOT>
		) { jjtThis.value = t.image; }
		UnaryExpression()
	)
}

public void MultiplicativeExpression() : { Token t = null; }
{
	UnaryExpression()
	(
		(
			t = <MULT> | 
			t = <DIV> | 
			t = <MOD>
		) { jjtThis.value = t.image; }
		UnaryExpression()
	)*
}

public void AdditiveExpression() : { Token t = null; }
{
	MultiplicativeExpression()
	( 
		LOOKAHEAD ( 2 ) 
		(
			t = <PLUS> | 
			t = <MINUS>
		) { jjtThis.value = t.image; }
		MultiplicativeExpression()
	)*
}

public void ShiftExpression() : { Token t = null; }
{
	AdditiveExpression()
	(
		( 
			t = <LSHIFT> | 
			t = <RSHIFT> | 
			t = <URSHIFT>
		) { jjtThis.value = t.image;  }
		AdditiveExpression()
	)*
}

public void RelationalExpression() : { Token t = null; }
{
	ShiftExpression()
	(
		( 
			t = <LT> | 
			t = <GT> | 
			t = <LTE> | 
			t = <GTE> | 
			t = <INSTANCEOF> | 
			t = <IN>
		) { jjtThis.value = t.image; }
		ShiftExpression()
	)*
}

public void RelationalExpressionNoIn() : { Token t = null; }
{
	ShiftExpression()
	(
		( 
			t = <LT> |
			t = <GT> |
			t = <LTE> |
			t = <GTE> |
			t = <INSTANCEOF>
		) { jjtThis.value = t.image; }
		ShiftExpression()
	)*
}

public void EqualityExpression() : { Token t = null; }
{
	RelationalExpression()
	( 
		( 
			t = <EQUAL> | 
			t = <NOT_EQUAL> | 
			t = <EEQUAL> | 
			t = <NOT_EEQUAL>
		) { jjtThis.value = t.image; }
		RelationalExpression()
	)*
}

public void EqualityExpressionNoIn() : { }
{
	RelationalExpressionNoIn() ( ( <EQUAL> | <NOT_EQUAL> | <EEQUAL> | <NOT_EEQUAL> ) RelationalExpressionNoIn() )*
}

public void BitwiseANDExpression() : { }
{
	EqualityExpression() ( <BAND> EqualityExpression() )*
}

public void BitwiseANDExpressionNoIn() : { }
{
	EqualityExpressionNoIn() ( <BAND> EqualityExpressionNoIn() )*
}

public void BitwiseXORExpression() : { }
{
	BitwiseANDExpression() ( <XOR> BitwiseANDExpression() )*
}

public void BitwiseXORExpressionNoIn() : { }
{
	BitwiseANDExpressionNoIn() ( <XOR> BitwiseANDExpressionNoIn() )*
}

public void BitwiseORExpression() : { }
{
	BitwiseXORExpression() ( <BOR> BitwiseXORExpression() )*
}

public void BitwiseORExpressionNoIn() : { }
{
	BitwiseXORExpressionNoIn() ( <BOR> BitwiseXORExpression() )*
}

public void LogicalANDExpression() : { }
{
	BitwiseORExpression() ( <AND> BitwiseORExpression() )*
}

public void LogicalANDExpressionNoIn() : { }
{
	BitwiseORExpressionNoIn() ( <AND> BitwiseORExpressionNoIn() )*
}

public void LogicalORExpression() : { }
{
	LogicalANDExpression() ( <OR> LogicalANDExpression() )*
}

public void LogicalORExpressionNoIn() : { }
{
	LogicalANDExpressionNoIn() ( <OR> LogicalANDExpressionNoIn() )*
}

public void ConditionalExpression() : { }
{
	LogicalORExpression() ( LOOKAHEAD ( <QUESTION> ) <QUESTION> AssignmentExpression() <COLON> AssignmentExpression() )*
}

public void ConditionalExpressionNoIn() : { }
{
	LogicalORExpressionNoIn() ( LOOKAHEAD ( <QUESTION> ) <QUESTION> AssignmentExpressionNoIn() <COLON> AssignmentExpressionNoIn() )*
}

public void AssignmentExpression() : { }
{
	LOOKAHEAD ( LeftHandSideExpression() AssignmentOperator() ) LeftHandSideExpression() AssignmentOperator() AssignmentExpression() | 
	ConditionalExpression()
}

public void AssignmentExpressionNoIn() : { }
{
	LOOKAHEAD ( LeftHandSideExpression() AssignmentOperator() ) LeftHandSideExpression() AssignmentOperator() AssignmentExpressionNoIn() |
	ConditionalExpressionNoIn()
}

public void AssignmentOperator() : { Token t = null;}
{
	(
		t = <ASSIGN> |
		t = <MULT_ASSIGN> |
		t = <DIV_ASSIGN> |
		t = <MOD_ASSIGN> |
		t = <PLUS_ASSIGN> |
		t = <MINUS_ASSIGN> |
		t = <LSHIFT_ASSIGN> |
		t = <RSHIFT_ASSIGN> |
		t = <URSHIFT_ASSIGN> |
		t = <BAND_ASSIGN> |
		t = <XOR_ASSIGN> |
		t = <BOR_ASSIGN>
	)
	{ jjtThis.value = t.image; }
}

public void Expression() : { }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void ExpressionNoIn() : { }
{
	AssignmentExpressionNoIn() ( <COMMA> AssignmentExpressionNoIn() )*
}



/*
 * Statements
 */

public void Statement() : { }
{
	LOOKAHEAD ( <LBRACE> ) Block() |
	// TODO: LINT Warning - Function Declarations should only appear at the SourceElement level
	LOOKAHEAD ( <FUNCTION> Identifier() ) FunctionDeclaration() |
	VariableStatement() |
	EmptyStatement() |
	ExpressionStatement() |
	IfStatement() |
	IterationStatement() |
	ContinueStatement() |
	BreakStatement() |
	ReturnStatement() |
	WithStatement() |
	LabelledStatement() |
	SwitchStatement() |
	ThrowStatement() |
	TryStatement() | 
	DebuggerStatement()
}

public void Block() : { }
{
	<LBRACE> ( StatementList() )? <RBRACE>
}

public void StatementList() : { }
{
	( Statement() )+
}

public void VariableStatement() : { }
{
	<VAR> VariableDeclarationList() ( LOOKAHEAD( <SEMICOLON> ) <SEMICOLON> )?
}

public void VariableDeclarationList() : { }
{
	VariableDeclaration() ( <COMMA> VariableDeclaration() )* 
}

public void VariableDeclarationListNoIn() : { }
{
	VariableDeclarationNoIn() ( <COMMA> VariableDeclarationNoIn() ) *
}

public void VariableDeclaration() : { }
{
	Identifier() (Initializer())?
}

public void VariableDeclarationNoIn() : { }
{
	Identifier() (InitializerNoIn())?
}

public void Initializer() : { }
{
	<ASSIGN> AssignmentExpression()
}

public void InitializerNoIn() : { }
{
	<ASSIGN> AssignmentExpressionNoIn()
}

public void EmptyStatement() : { }
{
	<SEMICOLON>
}

public void ExpressionStatement() : { }
{
	LOOKAHEAD ( { getToken(1).kind != LBRACE && 
					getToken(1).kind != COMMA &&
					getToken(1).kind != FUNCTION  } )
	Expression() ( LOOKAHEAD( <SEMICOLON> ) <SEMICOLON> )?
}

public void IfStatement() : { }
{
	<IF> <LPAREN> Expression() <RPAREN> Statement() ( LOOKAHEAD ( 2 ) <ELSE> Statement() )?
}

public void IterationStatement() : { }
{
	DoStatement() |
	WhileStatement() | 
	LOOKAHEAD ( <FOR> <LPAREN> (ForStatementInitializer())? <SEMICOLON> ) ForStatement() | 
	ForInStatement()
}

public void DoStatement() : {}
{
	<DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON>
}

public void WhileStatement() : {}
{
	<WHILE> <LPAREN> Expression() <RPAREN> Statement()
}

public void ForStatement() : {}
{
	<FOR> <LPAREN> (ForStatementInitializer())? <SEMICOLON> (ForStatementCondition())? <SEMICOLON> (ForStatementStep())? <RPAREN> Statement()
}

public void ForStatementInitializer() : { Token t = null; }
{
	LOOKAHEAD ( <VAR> ) t = <VAR> { jjtThis.value = t.image; } VariableDeclarationListNoIn() | 
	ExpressionNoIn()
}

public void ForStatementCondition() : {}
{
	Expression()
}

public void ForStatementStep() : {}
{
	Expression()
}

public void ForInStatement() :{}
{
	<FOR> <LPAREN> (ForInStatementInitializer())? <IN> Expression() <RPAREN> Statement()
}

public void ForInStatementInitializer() : { Token t = null; }
{
	LOOKAHEAD ( <VAR> ) t = <VAR> { jjtThis.value = t.image; } VariableDeclarationListNoIn() | 
	LeftHandSideExpression()
}

public void ContinueStatement() : { }
{
	<CONTINUE> ( LOOKAHEAD ( Identifier() ) Identifier() )? ( LOOKAHEAD ( <SEMICOLON> ) <SEMICOLON> )?
}

public void BreakStatement() : { }
{
	<BREAK> ( LOOKAHEAD ( Identifier() )  Identifier() )? ( LOOKAHEAD ( <SEMICOLON> ) <SEMICOLON> )?
}

public void ReturnStatement() : { }
{
	<RETURN> ( LOOKAHEAD ( Expression() ) Expression() )? ( LOOKAHEAD ( <SEMICOLON> ) <SEMICOLON> )?
}

public void WithStatement() : { }
{
	<WITH> <LPAREN> Expression() <LPAREN> Statement()
}

public void SwitchStatement() : { }
{
	<SWITCH> <LPAREN> Expression() <RPAREN> CaseBlock()
}

public void CaseBlock() : { }
{
	<LBRACE> (CaseClauses())? ( DefaultClause() (CaseClauses())? )? <RBRACE>
}

public void CaseClauses() : { }
{
	( CaseClause() )+
}

public void CaseClause() : { }
{
	<CASE> Expression() <COLON> (StatementList())?
}

public void DefaultClause() : { }
{
	<_DEFAULT> <COLON> (StatementList())?
}

public void LabelledStatement() : { }
{
	Identifier() <COLON> Statement()
}

public void ThrowStatement() : { }
{
	<THROW> Expression() <SEMICOLON>
}

public void TryStatement() : { }
{
	<TRY> Block() ( LOOKAHEAD ( Finally() ) Finally() | Catch() ( Finally() )? )
}

public void Catch() : { }
{
	<CATCH> <LPAREN> Identifier() <RPAREN> Block()
}

public void Finally() : { }
{
	<FINALLY> Block()
}

public void DebuggerStatement() : {}
{
	<DEBUGGER> <SEMICOLON>
}

/*
 * Functions and Programs
 */

public void FunctionDeclaration() : { }
{
	<FUNCTION> Identifier() <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FunctionExpression() : { }
{
	<FUNCTION> (Identifier())? <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FormalParameterList() : { }
{
	Identifier() ( <COMMA> Identifier() )*
}

public void FunctionBody() : { }
{
	SourceElements()
}

public SimpleNode Program() : { }
{
	SourceElements()
	{ return jjtThis; }
}

public void SourceElements() : { }
{
	( SourceElement() )*
}

public void SourceElement() : { }
{
	Statement()
}
