// TODO: Full Unicode Support
// TODO: Semicolon insertion (sec 7.9)

options
{
	STATIC = false;
	UNICODE_INPUT = true;
	DEBUG_PARSER = true;
//	LOOKAHEAD = 3;
}

PARSER_BEGIN(JavascriptParser)

class JavascriptParser
{

	public static void main(String args[]) throws Throwable
	{
		try
		{
			JavascriptParser p = new JavascriptParser(System.in);
			p.enable_tracing();
			p.SourceElements();
			System.out.println("ok");
			System.exit(0);
		}
		catch (Throwable t)
		{
			System.err.println(t.getMessage());
			System.exit(1);
		}
	}

	private void log(String msg)
	{
		System.out.println(msg);
	}

}

PARSER_END(JavascriptParser)

/*
 * Whitespace
 */

SKIP : 
{
	< [ "\t", /*"\v", "\f",*/ " ", "\r", "\n" ] >
}

/*
 * Comments
 */

SKIP : 
{
	< "//" (~["\n","\r"])* >
}

SKIP :
{
	"/*" : COMMENT
}

<COMMENT> SKIP :
{
	"*/" : DEFAULT
}

<COMMENT> SKIP : 
{
	< ~[] >
}

/*
 * Reserved Words
 */

TOKEN : 
{
	< ABSTRACT : "abstract" > |
	< AS : "as" > |
	< BOOLEAN : "boolean" > |
	< BREAK : "break" > |
	< BYTE : "byte" > |
	< CASE : "case" > |
	< CATCH : "catch" > |
	< CHAR : "char" > |
	< CLASS : "class" > |
	< CONTINUE : "continue" > |
	< CONST : "const" > |
	< DEBUGGER : "debugger" > |
	< _DEFAULT : "default" > |
	< DELETE : "delete" > |
	< DO : "do" > |
	< DOUBLE : "double" > |
	< ELSE : "else" > |
	< ENUM : "enum" > |
	< EXPORT : "export" > |
	< EXTENDS : "extends" > |
	< FALSE : "false" > |
	< FINAL : "final" > |
	< FINALLY : "finally" > |
	< FLOAT : "float" > |
	< FOR : "for" > |
	< FUNCTION : "function" > |
	< GOTO : "goto" > |
	< IF : "if" > |
	< IMPLEMENTS : "implements" > |
	< IMPORT : "import" > |
	< IN : "in" > |
	< INSTANCEOF : "instanceof" > |
	< INT : "int" > |
	< INTERFACE : "interface" > |
	< IS : "is" > |
	< LONG : "long" > |
	< NAMESPACE : "namespace" > |
	< NATIVE : "native" > |
	< NEW : "new" > |
	< NULL : "null" > |
	< PACKAGE : "package" > |
	< PRIVATE : "private" > |
	< PROTECTED : "protected" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< SHORT : "short" > |
	< STATIC : "static" > |
	< SUPER : "super" > |
	< SWITCH : "switch" > |
	< SYNCHRONIZED : "synchronized" > |
	< THIS : "this" > |
	< THROW : "throw" > |
	< THROWS : "throws" > |
	< TRANSIENT : "transient" > |
	< TRUE : "true" > |
	< TRY : "try" > |
	< TYPEOF : "typeof" > |
	< USE : "use" > |
	< VAR : "var" > |
	< VOID : "void" > |
	< VOLATILE : "volatile" > |
	< WHILE : "while" > |
	< WITH : "with" >
}

/*
 * Operators
 */

TOKEN :
{
	< DOT : "." > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< MULT : "*" > |
	< DIV : "/" > |
	< MOD : "%" > |
	< INC : "++" > |
	< DEC : "--" > |
	< ASSIGN : "=" > |
	< PLUS_ASSIGN : "+=" > |
	< MINUS_ASSIGN : "-=" > |
	< MULT_ASSIGN : "*=" > |
	< DIV_ASSIGN : "/=" > |
	< MOD_ASSIGN : "%=" > |
	< LSHIFT_ASSIGN : "<<=" > |
	< RSHIFT_ASSIGN : ">>=" > |
	< URSHIFT_ASSIGN : ">>>=" > |
	< BAND_ASSIGN : "&=" > |
	< BOR_ASSIGN : "|=" > |
	< XOR_ASSIGN : "^=" > |
	< EQUAL : "==" > |
	< EEQUAL : "===" > |
	< NOT_EQUAL : "!=" > |
	< NOT_EEQUAL : "!==" > |
	< LT : "<" > |
	< GT : ">" > |
	< LTE : "<=" > |
	< GTE : ">=" > |	
	< BAND : "&" > |
	< AND : "&&" > |
	< BOR : "|" > |
	< OR : "||" > |
	< XOR : "^" > |
	< BNOT : "~" > |
	< NOT : "!" > |
	< LPAREN : "(" > |
	< RPAREN : ")" > |
	< LBRACKET : "[" > |
	< RBRACKET : "]" > |
	< LBRACE : "{" > |
	< RBRACE : "}" > |
	< QUESTION : "?" > |
	< COLON : ":" > |
	< SEMICOLON : ";" > |
	< LSHIFT : "<<" > |
	< RSHIFT : ">>" > |
	< URSHIFT : ">>>" > |
	< COMMA : "," >
}

/*
 * Complex Tokens
 */

TOKEN :
{

	// Identifiers
	< IDENTIFIER : <IDENTIFIER_START> (<IDENTIFIER_START> | <IDENTIFIER_CHAR>)* > |
	< #IDENTIFIER_START : ( [ "$","_","A"-"Z","a"-"z" ] )> |
	< #IDENTIFIER_CHAR : ( [ "$","_","A"-"Z","a"-"z","0"-"9" ] ) >  |

	// Numeric Literals
	< DECIMAL_LITERAL : (
		<DECIMAL_INTEGER_LITERAL> <DOT> (<DECIMAL_DIGITS>)? (<EXPONENT_PART>)? | 
		<DOT> <DECIMAL_DIGITS> (<EXPONENT_PART>)? |
		<DECIMAL_INTEGER_LITERAL> (<EXPONENT_PART>)? ) > |
	
	< #DECIMAL_INTEGER_LITERAL : ( "0" | <NON_ZERO_DIGIT> (<DECIMAL_DIGITS>)? ) > |
	< #DECIMAL_DIGITS : ( <DECIMAL_DIGIT> )+ > |
	< #DECIMAL_DIGIT : ( [ "0"-"9" ] ) > |
	< #NON_ZERO_DIGIT : ( [ "1"-"9" ] ) > |
	< #EXPONENT_PART : ( <EXPONENT_INDICATOR> <SIGNED_INTEGER> ) > |
	< #EXPONENT_INDICATOR : ( "e" | "E" ) > |
	< #SIGNED_INTEGER : ( <DECIMAL_DIGITS> | <PLUS> <DECIMAL_DIGITS> | <MINUS> <DECIMAL_DIGITS> ) > |

	< HEX_INTEGER_LITERAL : ( ( "0x" | "0X") ( <HEX_DIGIT> )+ ) > |
	< #HEX_DIGIT : ( [ "0"-"9", "a"-"f", "A"-"F" ] ) > |


	// String Literals
	< STRING_LITERAL : ( "\"" <DOUBLE_QUOTED_STRING_CHARS> "\"" | "'" <SINGLE_QUOTED_STRING_CHARS> "'" ) > |
	< #DOUBLE_QUOTED_STRING_CHARS : ( <DOUBLE_QUOTED_STRING_CHAR> | <ESCAPE_SEQUENCE> )* > |
	< #DOUBLE_QUOTED_STRING_CHAR : ( ~["\\", "\"", "\r", "\n"] ) > |

	< #SINGLE_QUOTED_STRING_CHARS : ( <SINGLE_QUOTED_STRING_CHAR> | <ESCAPE_SEQUENCE> )* > |
	< #SINGLE_QUOTED_STRING_CHAR : ( ~["\\", "'", "\r", "\n"] ) > |

	< #ESCAPE_SEQUENCE : ( "\\" ( <CHARACTER_ESCAPE_SEQUENCE> | <HEX_ESCAPE_SEQUENCE> | <UNICODE_ESCAPE_SEQUENCE> ) ) > |
	< #CHARACTER_ESCAPE_SEQUENCE : ( <SINGLE_ESCAPE_CHARACTER> | <HEX_ESCAPE_SEQUENCE> | <UNICODE_ESCAPE_SEQUENCE> ) > |
	< #SINGLE_ESCAPE_CHARACTER : ["'", "\"", "\\", "b", "f", "n", "r", "t", "v"] > |
	< #HEX_ESCAPE_SEQUENCE : ( "x" <HEX_DIGIT> <HEX_DIGIT> ) > |
	< #UNICODE_ESCAPE_SEQUENCE: ( "u" <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> ) > |

	// Regex Literals
	// TODO: Revisit when refactoring lexemes for unicode.
	< REGEX_LITERAL : ("/" <REGEX_BODY> "/" ( <REGEX_FLAGS> )? ) > |
	< #REGEX_BODY : ( <REGEX_FIRST_CHAR> <REGEX_CHARS> ) > |
	< #REGEX_CHARS : ( <REGEX_CHAR> )* > |
	< #REGEX_FIRST_CHAR : ( ~["\r", "\n", "*", "/", "\\"] | <BACKSLASH_SEQUENCE> ) > |
	< #REGEX_CHAR : ( ~[ "\r", "\n", "/", "\\" ] | <BACKSLASH_SEQUENCE> ) > |
	< #BACKSLASH_SEQUENCE : ("\\" ~[ "\r", "\n"] ) > |
	< #REGEX_FLAGS : ( <IDENTIFIER_CHAR> )* >
	
}



public void Identifier() : { }
{
	<IDENTIFIER>
}


public void Literal() : { }
{
	NullLiteral() | 
	BooleanLiteral() |
	NumericLiteral() |
	StringLiteral() |
	RegExLiteral()
}

public void NullLiteral() : { }
{
	<NULL>
}

public void BooleanLiteral() : { }
{
	<TRUE> |
	<FALSE>
}

public void NumericLiteral() : { }
{
	<DECIMAL_LITERAL> |
	<HEX_INTEGER_LITERAL>
}

public void StringLiteral() : { }
{
	<STRING_LITERAL>
}

public void RegExLiteral() : { }
{
	<REGEX_LITERAL>
}

/*
 * Expressions
 */

public void PrimaryExpression() : { }
{
	<THIS> |
	Identifier() |
	Literal() |
	ArrayLiteral() |
	ObjectLiteral() |
	<LPAREN> Expression() <RPAREN>
}

public void ArrayLiteral() : { }
{
	<LBRACKET> (ElementList())? <RBRACKET>
}

public void ElementList() : { }
{
	(Elsion())? AssignmentExpression() ( <COMMA> (Elsion())? AssignmentExpression() )*
}

public void Elsion() : { }
{
	( <COMMA> )+
}

public void ObjectLiteral() : { }
{
	<LBRACE> ( PropertyNameAndValueList() )* <RBRACE>
}

public void PropertyNameAndValueList() : { }
{
	PropertyName() <COLON> AssignmentExpression() ( <COMMA> PropertyName() <COLON> AssignmentExpression() )*
}

public void PropertyName() : { }
{
	Identifier() |
	StringLiteral() |
	NumericLiteral()
}

public void MemberExpression() : { }
{
	( LOOKAHEAD ( <FUNCTION> ) FunctionExpression() | PrimaryExpression() ) ( LOOKAHEAD( 2 ) MemberExpressionCont() )* |
	NewExpression()	

	

//	( LOOKAHEAD ( <FUNCTION> ) FunctionExpression() | LOOKAHEAD ( <NEW> ) NewExpression() Arguments() | PrimaryExpression() ) ( LOOKAHEAD( 2 ) MemberExpressionCont() )*// |
//	<NEW> MemberExpression() Arguments()
}

public void MemberExpressionCont() : { }
{
	( <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )
}

public void NewExpression() : { }
{
	<NEW> MemberExpression() ( LOOKAHEAD (2) MemberExpressionCont() )*

//	LOOKAHEAD ( 3 ) MemberExpression() |
//	<NEW> NewExpression()
}

public void CallExpression() : { }
{
	MemberExpression() Arguments() ( LOOKAHEAD ( 2 ) CallExpressionCont() )*
}

public void CallExpressionCont() : { }
{
	( Arguments() | <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )
}	

public void Arguments() : { }
{
	LOOKAHEAD ( 2 ) <LPAREN> <RPAREN> |
	<LPAREN> ArgumentList() <RPAREN>
}

public void ArgumentList() : { }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void LeftHandSideExpression() : { }
{
	LOOKAHEAD ( CallExpression() ) CallExpression() | 
	MemberExpression()
}

public void PostfixExpression() : { }
{
	LeftHandSideExpression() ( LOOKAHEAD ( 1 ) PostfixOperator() )?
}

public void PostfixOperator() : {}
{
	( <INC> | <DEC> )
}

public void UnaryExpression() : { }
{
	PostfixExpression() |
	<DELETE> UnaryExpression() |
	<VOID> UnaryExpression() |
	<TYPEOF> UnaryExpression() |
	<INC> UnaryExpression() |
	<DEC> UnaryExpression() |
	<PLUS> UnaryExpression() |
	<MINUS> UnaryExpression() |
	<BNOT> UnaryExpression() |
	<NOT> UnaryExpression()
}

public void MultiplicativeExpression() : { }
{
	UnaryExpression() ( ( <MULT> | <DIV> | <MOD> ) UnaryExpression() )*
}

public void AdditiveExpression() : { }
{
	MultiplicativeExpression() ( LOOKAHEAD ( 2 ) ( <PLUS> | <MINUS> ) MultiplicativeExpression() )*
}

public void ShiftExpression() : { }
{
	AdditiveExpression() ( ( <LSHIFT> | <RSHIFT> | <URSHIFT> ) AdditiveExpression() )*
}

public void RelationalExpression() : { }
{
	ShiftExpression() ( ( <LT> | <GT> | <LTE> | <GTE> | <INSTANCEOF> | <IN> ) ShiftExpression() )*
}

public void RelationalExpressionNoIn() : { }
{
	ShiftExpression() ( ( <LT> | <GT> | <LTE> | <GTE> | <INSTANCEOF> ) ShiftExpression() )*
}

public void EqualityExpression() : { }
{
	RelationalExpression() ( ( <EQUAL> | <NOT_EQUAL> | <EEQUAL> | <NOT_EEQUAL> ) RelationalExpression() )*
}

public void EqualityExpressionNoIn() : { }
{
	RelationalExpressionNoIn() ( ( <EQUAL> | <NOT_EQUAL> | <EEQUAL> | <NOT_EEQUAL> ) RelationalExpressionNoIn() )*
}

public void BitwiseANDExpression() : { }
{
	EqualityExpression() ( <BAND> EqualityExpression() )*
}

public void BitwiseANDExpressionNoIn() : { }
{
	EqualityExpressionNoIn() ( <BAND> EqualityExpressionNoIn() )*
}

public void BitwiseXORExpression() : { }
{
	BitwiseANDExpression() ( <XOR> BitwiseANDExpression() )*
}

public void BitwiseXORExpressionNoIn() : { }
{
	BitwiseANDExpressionNoIn() ( <XOR> BitwiseANDExpressionNoIn() )*
}

public void BitwiseORExpression() : { }
{
	BitwiseXORExpression() ( <BOR> BitwiseXORExpression() )*
}

public void BitwiseORExpressionNoIn() : { }
{
	BitwiseXORExpressionNoIn() ( <BOR> BitwiseXORExpression() )*
}

public void LogicalANDExpression() : { }
{
	BitwiseORExpression() ( <AND> BitwiseORExpression() )*
}

public void LogicalANDExpressionNoIn() : { }
{
	BitwiseORExpressionNoIn() ( <AND> BitwiseORExpressionNoIn() )*
}

public void LogicalORExpression() : { }
{
	LogicalANDExpression() ( <OR> LogicalANDExpression() )*
}

public void LogicalORExpressionNoIn() : { }
{
	LogicalANDExpressionNoIn() ( <OR> LogicalANDExpressionNoIn() )*
}

public void ConditionalExpression() : { }
{
	LogicalORExpression() ( LOOKAHEAD ( <QUESTION> ) <QUESTION> AssignmentExpression() <COLON> AssignmentExpression() )*
}

public void ConditionalExpressionNoIn() : { }
{
	LogicalORExpressionNoIn() ( LOOKAHEAD ( <QUESTION> ) <QUESTION> AssignmentExpressionNoIn() <COLON> AssignmentExpressionNoIn() )*
}

public void AssignmentExpression() : { }
{
	LOOKAHEAD ( LeftHandSideExpression() AssignmentOperator() ) LeftHandSideExpression() AssignmentOperator() AssignmentExpression() | 
	ConditionalExpression()
}

public void AssignmentExpressionNoIn() : { }
{
	LOOKAHEAD ( LeftHandSideExpression() AssignmentOperator() ) LeftHandSideExpression() AssignmentOperator() AssignmentExpressionNoIn() |
	ConditionalExpressionNoIn()
}

public void AssignmentOperator() : { }
{
	<ASSIGN> |
	<MULT_ASSIGN> |
	<DIV_ASSIGN> |
	<MOD_ASSIGN> |
	<PLUS_ASSIGN> |
	<MINUS_ASSIGN> |
	<LSHIFT_ASSIGN> |
	<RSHIFT_ASSIGN> |
	<URSHIFT_ASSIGN> |
	<BAND_ASSIGN> |
	<XOR_ASSIGN> |
	<BOR_ASSIGN>
}

public void Expression() : { }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void ExpressionNoIn() : { }
{
	AssignmentExpressionNoIn() ( <COMMA> AssignmentExpressionNoIn() )*
}



/*
 * Statements
 */

public void Statement() : { }
{
	LOOKAHEAD ( <LBRACE> ) Block() |
	LOOKAHEAD ( <FUNCTION> Identifier() ) FunctionDeclaration() |
	VariableStatement() |
	EmptyStatement() |
	ExpressionStatement() |
	IfStatement() |
	IterationStatement() |
	ContinueStatement() |
	BreakStatement() |
	ReturnStatement() |
	WithStatement() |
	LabelledStatement() |
	SwitchStatement() |
	ThrowStatement() |
	TryStatement() | 
	DebuggerStatement()
}

public void Block() : { }
{
	<LBRACE> ( StatementList() )? <RBRACE>
}

public void StatementList() : { }
{
	( Statement() )+
}

public void VariableStatement() : { }
{
	<VAR> VariableDeclarationList() ( LOOKAHEAD( <SEMICOLON> ) <SEMICOLON> )?
}

public void VariableDeclarationList() : { }
{
	VariableDeclaration() ( <COMMA> VariableDeclaration() )* 
}

public void VariableDeclarationListNoIn() : { }
{
	VariableDeclarationNoIn() ( <COMMA> VariableDeclarationNoIn() ) *
}

public void VariableDeclaration() : { }
{
	Identifier() (Initializer())?
}

public void VariableDeclarationNoIn() : { }
{
	Identifier() (InitializerNoIn())?
}

public void Initializer() : { }
{
	<ASSIGN> AssignmentExpression()
}

public void InitializerNoIn() : { }
{
	<ASSIGN> AssignmentExpressionNoIn()
}

public void EmptyStatement() : { }
{
	<SEMICOLON>
}

public void ExpressionStatement() : { }
{
	LOOKAHEAD ( { getToken(1).kind != LBRACE && 
					getToken(1).kind != COMMA &&
					getToken(1).kind != FUNCTION  } )
	Expression() ( LOOKAHEAD( <SEMICOLON> ) <SEMICOLON> )?
}

public void IfStatement() : { }
{
	<IF> <LPAREN> Expression() <RPAREN> Statement() ( LOOKAHEAD ( 2 ) <ELSE> Statement() )?
}

public void IterationStatement() : { }
{
	<DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON> |
	<WHILE> <LPAREN> Expression() <RPAREN> Statement() |

	<FOR> <LPAREN>
	(
		LOOKAHEAD ( (ExpressionNoIn())? <SEMICOLON> ) (ExpressionNoIn())? <SEMICOLON> (Expression())? <SEMICOLON> (Expression())? |
		LOOKAHEAD ( <VAR> VariableDeclarationListNoIn() <SEMICOLON> ) <VAR> VariableDeclarationListNoIn() <SEMICOLON> (Expression())? <SEMICOLON> (Expression())? |
		LOOKAHEAD ( <VAR> LeftHandSideExpression() ) <VAR> LeftHandSideExpression() <IN> Expression() |
		LOOKAHEAD ( LeftHandSideExpression() ) LeftHandSideExpression() <IN> Expression()
	)
	<RPAREN> Statement()
}

public void ContinueStatement() : { }
{
	<CONTINUE> (Identifier())? <SEMICOLON>
}

public void BreakStatement() : { }
{
	<BREAK> (Identifier())? <SEMICOLON>
}

public void ReturnStatement() : { }
{
	<RETURN> (Expression())? <SEMICOLON>
}

public void WithStatement() : { }
{
	<WITH> <LPAREN> Expression() <LPAREN> Statement()
}

public void SwitchStatement() : { }
{
	<SWITCH> <LPAREN> Expression() <RPAREN> CaseBlock()
}

public void CaseBlock() : { }
{
	<LBRACE> (CaseClauses())? ( DefaultClause() (CaseClauses())? )? <RBRACE>
}

public void CaseClauses() : { }
{
	( CaseClause() )+
}

public void CaseClause() : { }
{
	<CASE> Expression() <COLON> (StatementList())?
}

public void DefaultClause() : { }
{
	<_DEFAULT> <COLON> (StatementList())?
}

public void LabelledStatement() : { }
{
	Identifier() <COLON> Statement()
}

public void ThrowStatement() : { }
{
	<THROW> Expression() <SEMICOLON>
}

public void TryStatement() : { }
{
	<TRY> Block() ( LOOKAHEAD ( Finally() ) Finally() | Catch() ( Finally() )? )

//	LOOKAHEAD (3) <TRY> Block() Catch() |
//	LOOKAHEAD (3) <TRY> Block() Finally() |
//	LOOKAHEAD (3) <TRY> Block() Catch() Finally()
}

public void Catch() : { }
{
	<CATCH> <LPAREN> Identifier() <RPAREN> Block()
}

public void Finally() : { }
{
	<FINALLY> Block()
}

public void DebuggerStatement() : {}
{
	<DEBUGGER> <SEMICOLON>
}

/*
 * Functions and Programs
 */

public void FunctionDeclaration() : { }
{
	<FUNCTION> Identifier() <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FunctionExpression() : { }
{
	<FUNCTION> (Identifier())? <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FormalParameterList() : { }
{
	Identifier() ( <COMMA> Identifier() )*
}

public void FunctionBody() : { }
{
	SourceElements()
}

public void	Program() : { }
{
	SourceElements()
}

public void SourceElements() : { }
{
	( SourceElement() )*
}

public void SourceElement() : { }
{
	Statement()// |
//	FunctionDeclaration()
}
