options
{
	STATIC = false;
	UNICODE_INPUT = true;
	LOOKAHEAD = 3;
}

PARSER_BEGIN(JavascriptParser)

class JavascriptParser
{

	public static void main(String args[]) throws Throwable
	{
		new JavascriptParser(System.in).StatementList();
	}

	private void log(String msg)
	{
		System.out.println(msg);
	}

}

PARSER_END(JavascriptParser)

SKIP : 
{
	< [ " ", "\t", "\r", "\n" ] >
}

TOKEN : 
{
	< ABSTRACT : "abstract" > |
	< AS : "as" > |
	< BOOLEAN : "boolean" > |
	< BREAK : "break" > |
	< BYTE : "byte" > |
	< CASE : "case" > |
	< CATCH : "catch" > |
	< CHAR : "char" > |
	< CLASS : "class" > |
	< CONTINUE : "continue" > |
	< CONST : "const" > |
	< DEBUGGER : "debugger" > |
	< _DEFAULT : "default" > |
	< DELETE : "delete" > |
	< DO : "do" > |
	< DOUBLE : "double" > |
	< ELSE : "else" > |
	< ENUM : "enum" > |
	< EXPORT : "export" > |
	< EXTENDS : "extends" > |
	< FALSE : "false" > |
	< FINAL : "final" > |
	< FINALLY : "finally" > |
	< FLOAT : "float" > |
	< FOR : "for" > |
	< FUNCTION : "function" > |
	< GOTO : "goto" > |
	< IF : "if" > |
	< IMPLEMENTS : "implements" > |
	< IMPORT : "import" > |
	< IN : "in" > |
	< INSTANCEOF : "instanceof" > |
	< INT : "int" > |
	< INTERFACE : "interface" > |
	< IS : "is" > |
	< LONG : "long" > |
	< NAMESPACE : "namespace" > |
	< NATIVE : "native" > |
	< NEW : "new" > |
	< NULL : "null" > |
	< PACKAGE : "package" > |
	< PRIVATE : "private" > |
	< PROTECTED : "protected" > |
	< PUBLIC : "public" > |
	< RETURN : "return" > |
	< SHORT : "short" > |
	< STATIC : "static" > |
	< SUPER : "super" > |
	< SWITCH : "switch" > |
	< SYNCHRONIZED : "synchronized" > |
	< THIS : "this" > |
	< THROW : "throw" > |
	< THROWS : "throws" > |
	< TRANSIENT : "transient" > |
	< TRUE : "true" > |
	< TRY : "try" > |
	< TYPEOF : "typeof" > |
	< USE : "use" > |
	< VAR : "var" > |
	< VOID : "void" > |
	< VOLATILE : "volatile" > |
	< WHILE : "while" > |
	< WITH : "with" >
}

TOKEN :
{
	< DOT : "." > |
	< PLUS : "+" > |
	< MINUS : "-" > |
	< MULT : "*" > |
	< DIV : "/" > |
	< MOD : "%" > |
	< INC : "++" > |
	< DEC : "--" > |
	< ASSIGN : "=" > |
	< PLUS_ASSIGN : "+=" > |
	< MINUS_ASSIGN : "-=" > |
	< MULT_ASSIGN : "*=" > |
	< DIV_ASSIGN : "/=" > |
	< MOD_ASSIGN : "%=" > |
	< LSHIFT_ASSIGN : "<<=" > |
	< RSHIFT_ASSIGN : ">>=" > |
	< URSHIFT_ASSIGN : ">>>=" > |
	< BAND_ASSIGN : "&=" > |
	< BOR_ASSIGN : "|=" > |
	< XOR_ASSIGN : "^=" > |
	< EQUAL : "==" > |
	< EEQUAL : "===" > |
	< NOT_EQUAL : "!=" > |
	< NOT_EEQUAL : "!==" > |
	< LT : "<" > |
	< GT : ">" > |
	< LTE : "<=" > |
	< GTE : ">=" > |	
	< BAND : "&" > |
	< AND : "&&" > |
	< BOR : "|" > |
	< OR : "||" > |
	< XOR : "^" > |
	< BNOT : "~" > |
	< NOT : "!" > |
	< LPAREN : "(" > |
	< RPAREN : ")" > |
	< LBRACKET : "[" > |
	< RBRACKET : "]" > |
	< LBRACE : "{" > |
	< RBRACE : "}" > |
	< QUESTION : "?" > |
	< COLON : ":" > |
	< SEMICOLON : ";" > |
	< LSHIFT : "<<" > |
	< RSHIFT : ">>" > |
	< URSHIFT : ">>>" > |
	< COMMA : "," >
}

TOKEN : 
{
	< IDENTIFIER : <IDENTIFIER_START> (<IDENTIFIER_START> | <IDENTIFIER_CHAR>)* > |
	< #IDENTIFIER_START : ( [ "$","_","A"-"Z","a"-"z" ] )> |
	< #IDENTIFIER_CHAR : ( [ "$","_","A"-"Z","a"-"z","0"-"9" ] ) >  
}

MORE :
{
	"\"" : STRLIT
}

<STRLIT> MORE :
{
	< ~[] >
}

<STRLIT> TOKEN : 
{
	< STRING_LITERAL : "\"" > : DEFAULT
}

TOKEN :
{
	< DECIMAL_LITERAL : (
		<DECIMAL_INTEGER_LITERAL> <DOT> (<DECIMAL_DIGITS>)? (<EXPONENT_PART>)? | 
		<DOT> <DECIMAL_DIGITS> (<EXPONENT_PART>)? |
		<DECIMAL_INTEGER_LITERAL> (<EXPONENT_PART>)? ) > |
	
	< #DECIMAL_INTEGER_LITERAL : ( "0" | <NON_ZERO_DIGIT> (<DECIMAL_DIGITS>)? ) > |
	< #DECIMAL_DIGITS : ( <DECIMAL_DIGIT> )+ > |
//	< #DECIMAL_DIGITS : ( <DECIMAL_DIGIT> | <DECIMAL_DIGITS> <DECIMAL_DIGIT> ) > |
	< #DECIMAL_DIGIT : ( [ "0"-"9" ] ) > |
	< #NON_ZERO_DIGIT : ( [ "1"-"9" ] ) > |
	< #EXPONENT_PART : ( <EXPONENT_INDICATOR> <SIGNED_INTEGER> ) > |
	< #EXPONENT_INDICATOR : ( "e" | "E" ) > |
	< #SIGNED_INTEGER : ( <DECIMAL_DIGITS> | <PLUS> <DECIMAL_DIGITS> | <MINUS> <DECIMAL_DIGITS> ) > |

	< HEX_INTEGER_LITERAL : ( ( "0x" | "0X") ( <HEX_DIGIT> )+ ) > |
//	< HEX_INTEGER_LITERAL : ( ( "0x" | "0X") <HEX_DIGIT> | <HEX_INTEGER_LITERAL> <HEX_DIGIT>) > |
	< #HEX_DIGIT : ( [ "0"-"9", "a"-"f", "A"-"F" ] ) >
	
}


/*
 * TODO: String Literals
 * TODO: Numeric/Float Literals
 */

public void Identifier() : { log("Identifier"); }
{
	<IDENTIFIER>
}


public void Literal() : { log("Literal"); }
{
	NullLiteral() | 
	BooleanLiteral() |
	NumericLiteral() |
	StringLiteral()
}

public void NullLiteral() : { log("NullLiteral"); }
{
	<NULL>
}

public void BooleanLiteral() : { log("BooleanLiteral"); }
{
	<TRUE> |
	<FALSE>
}

public void NumericLiteral() : { log("NumericLiteral"); }
{
	<DECIMAL_LITERAL> |
	<HEX_INTEGER_LITERAL>
}

public void StringLiteral() : { log("StringLiteral"); }
{
	<STRING_LITERAL>
}


/*
 * Expressions
 */

public void PrimaryExpression() : { log("PrimaryExpression"); }
{
	<THIS> |
	Identifier() |
	Literal() |
	ArrayLiteral() |
	ObjectLiteral() |
	<LPAREN> Expression() <RPAREN>
}

public void ArrayLiteral() : { log("ArrayLiteral"); }
{
	<LBRACKET> (Elsion())? <RBRACKET> |
	<LBRACKET> ElementList() <RBRACKET> |
	<LBRACKET> ElementList() <COMMA> (Elsion())? <RBRACKET>
}

public void ElementList() : { log("ElementList"); }
{
	(Elsion())? AssignmentExpression() ( <COMMA> (Elsion())? AssignmentExpression() )*
}

public void Elsion() : { log("Elsion"); }
{
	( <COMMA> )+
}

public void ObjectLiteral() : { log("ObjectLiteral"); }
{
	<LBRACE> <RBRACE> |
	<LBRACE> PropertyNameAndValueList() <RBRACE>
}

public void PropertyNameAndValueList() : { log("PropertyNameAndValueList"); }
{
	PropertyName() <COLON> AssignmentExpression() ( <COMMA> PropertyName() <COLON> AssignmentExpression() )*
}

public void PropertyName() : { log("PropertyName"); }
{
	Identifier() |
	StringLiteral() |
	NumericLiteral()
}

public void MemberExpression() : { log("MemberExpression"); }
{
	( PrimaryExpression() | FunctionExpression() ) ( <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )* |
	<NEW> MemberExpression() Arguments()

//	PrimaryExpression() |
//	FunctionExpression() |
//	MemberExpression() <LBRACKET> Expression() <RBRACKET> |
//	MemberExpression() <DOT> Identifier() |
//	<NEW> MemberExpression() Arguments()
}

public void NewExpression() : { log("NewExpression"); }
{
	MemberExpression() |
	<NEW> NewExpression()
}

public void CallExpression() : { log("CallExpression"); }
{
	MemberExpression() Arguments() ( Arguments()  | <LBRACKET> Expression() <RBRACKET> | <DOT> Identifier() )*
//	MemberExpression() Arguments() |
//	CallExpression() Arguments() |
//	CallExpression() <LBRACKET> Expression() <RBRACKET> |
//	CallExpression() <DOT> Identifier()
}

public void Arguments() : { log("Arguments"); }
{
	<LPAREN> <RPAREN> |
	<LPAREN> ArgumentList() <RPAREN>
}

public void ArgumentList() : { log("ArgumentList"); }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void LeftHandSideExpression() : { log("LeftHandSideExpression"); }
{
	NewExpression() |
	CallExpression()
}

public void PostfixExpression() : { log("PostfixExpression"); }
{
	LeftHandSideExpression() |
	LeftHandSideExpression() <INC> |
	LeftHandSideExpression() <DEC>
}

public void UnaryExpression() : { log("UnaryExpression"); }
{
	PostfixExpression() |
	<DELETE> UnaryExpression() |
	<VOID> UnaryExpression() |
	<TYPEOF> UnaryExpression() |
	<INC> UnaryExpression() |
	<DEC> UnaryExpression() |
	<PLUS> UnaryExpression() |
	<MINUS> UnaryExpression() |
	<BNOT> UnaryExpression() |
	<NOT> UnaryExpression()
}

public void MultiplicativeExpression() : { log("MultiplicativeExpression"); }
{
	UnaryExpression() ( ( <MULT> | <DIV> | <MOD> ) UnaryExpression() )*
//	UnaryExpression() |
//	MultiplicativeExpression() <MULT> UnaryExpression() |
//	MultiplicativeExpression() <DIV> UnaryExpression() |
//	MultiplicativeExpression() <MOD> UnaryExpression()
}

public void AdditiveExpression() : { log("AdditiveExpression"); }
{
	MultiplicativeExpression() ( ( <PLUS> | <MINUS> ) MultiplicativeExpression() )*
//	MultiplicativeExpression() |
//	AdditiveExpression() <PLUS> MultiplicativeExpression() |
//	AdditiveExpression() <MINUS> MultiplicativeExpression()
}

public void ShiftExpression() : { log("ShiftExpression"); }
{
	AdditiveExpression() ( ( <LSHIFT> | <RSHIFT> | <URSHIFT> ) AdditiveExpression() )*
//	AdditiveExpression() |
//	ShiftExpression() <LSHIFT> AdditiveExpression() |
//	ShiftExpression() <RSHIFT> AdditiveExpression() |
//	ShiftExpression() <URSHIFT> AdditiveExpression()
}

public void RelationalExpression() : { log("RelationalExpression"); }
{
	ShiftExpression() ( ( <LT> | <GT> | <LTE> | <GTE> | <INSTANCEOF> | <IN> ) ShiftExpression() )*
//	ShiftExpression() |
//	RelationalExpression() <LT> ShiftExpression() |
//	RelationalExpression() <GT> ShiftExpression() |
//	RelationalExpression() <LTE> ShiftExpression() |
//	RelationalExpression() <GTE> ShiftExpression() |
//	RelationalExpression() <INSTANCEOF> ShiftExpression() |
//	RelationalExpression() <IN> ShiftExpression()
}


public void RelationalExpressionNoIn() : { log("RelationalExpressionNoIn"); }
{
	ShiftExpression() ( ( <LT> | <GT> | <LTE> | <GTE> | <INSTANCEOF> ) ShiftExpression() )*
//	ShiftExpression() |
//	RelationalExpressionNoIn() <LT> ShiftExpression() |
//	RelationalExpressionNoIn() <GT> ShiftExpression() |
//	RelationalExpressionNoIn() <LTE> ShiftExpression() |
//	RelationalExpressionNoIn() <GTE> ShiftExpression() |
//	RelationalExpressionNoIn() <INSTANCEOF> ShiftExpression()
}

public void EqualityExpression() : { log("EqualityExpression"); }
{
	RelationalExpression() ( ( <EQUAL> | <NOT_EQUAL> | <EEQUAL> | <NOT_EEQUAL> ) RelationalExpression() )*
//	RelationalExpression() |
//	EqualityExpression() <EQUAL> RelationalExpression() |
//	EqualityExpression() <NOT_EQUAL> RelationalExpression() |
//	EqualityExpression() <EEQUAL> RelationalExpression() |
//	EqualityExpression() <NOT_EEQUAL> RelationalExpression()
}

public void EqualityExpressionNoIn() : { log("EqualityExpressionNoIn"); }
{
	RelationalExpressionNoIn() ( ( <EQUAL> | <NOT_EQUAL> | <EEQUAL> | <NOT_EEQUAL> ) RelationalExpressionNoIn() )*
//	RelationalExpressionNoIn() |
//	EqualityExpressionNoIn() <EQUAL> RelationalExpressionNoIn() |
//	EqualityExpressionNoIn() <NOT_EQUAL> RelationalExpressionNoIn() |
//	EqualityExpressionNoIn() <EEQUAL> RelationalExpressionNoIn() |
//	EqualityExpressionNoIn() <NOT_EEQUAL> RelationalExpressionNoIn()
}

public void BitwiseANDExpression() : { log("BitwiseANDExpression"); }
{
	EqualityExpression() ( <BAND> EqualityExpression() )*
//	EqualityExpression() |
//	BitwiseANDExpression () <BAND> EqualityExpression()
}

public void BitwiseANDExpressionNoIn() : { log("BitwiseANDExpressionNoIn"); }
{
	EqualityExpressionNoIn() ( <BAND> EqualityExpressionNoIn() )*
//	EqualityExpressionNoIn() |
//	BitwiseANDExpressionNoIn () <BAND> EqualityExpressionNoIn()
}

public void BitwiseXORExpression() : { log("BitwiseXORExpression"); }
{
	BitwiseANDExpression() ( <XOR> BitwiseANDExpression() )*
//	BitwiseANDExpression() |
//	BitwiseXORExpression() <XOR> BitwiseANDExpression()
}

public void BitwiseXORExpressionNoIn() : { log("BitwiseXORExpressionNoIn"); }
{
	BitwiseANDExpressionNoIn() ( <XOR> BitwiseANDExpressionNoIn() )*
//	BitwiseANDExpressionNoIn() |
//	BitwiseXORExpressionNoIn() <XOR> BitwiseANDExpressionNoIn()
}

public void BitwiseORExpression() : { log("BitwiseORExpression"); }
{
	BitwiseXORExpression() ( <BOR> BitwiseXORExpression() )*
//	BitwiseXORExpression() |
//	BitwiseORExpression() <BOR> BitwiseXORExpression()
}

public void BitwiseORExpressionNoIn() : { log("BitwiseORExpressionNoIn"); }
{
	BitwiseXORExpressionNoIn() ( <BOR> BitwiseXORExpression() )*
//	BitwiseXORExpressionNoIn() |
//	BitwiseORExpressionNoIn() <BOR> BitwiseXORExpressionNoIn()
}

public void LogicalANDExpression() : { log("LogicalANDExpression"); }
{
	BitwiseORExpression() ( <AND> BitwiseORExpression() )*
//	BitwiseORExpression() |
//	LogicalANDExpression() <AND> BitwiseORExpression()
}

public void LogicalANDExpressionNoIn() : { log("LogicalANDExpressionNoIn"); }
{
	BitwiseORExpressionNoIn() ( <AND> BitwiseORExpressionNoIn() )*
//	BitwiseORExpressionNoIn() |
//	LogicalANDExpressionNoIn() <AND> BitwiseORExpressionNoIn()
}

public void LogicalORExpression() : { log("LogicalORExpression"); }
{
	LogicalANDExpression() ( <OR> LogicalANDExpression() )*
//	LogicalANDExpression() |
//	LogicalORExpression() <OR> LogicalANDExpression()
}

public void LogicalORExpressionNoIn() : { log("LogicalORExpressionNoIn"); }
{
	LogicalANDExpressionNoIn() ( <OR> LogicalANDExpressionNoIn() )*
//	LogicalANDExpressionNoIn() |
//	LogicalORExpressionNoIn() <OR> LogicalANDExpressionNoIn()
}

public void ConditionalExpression() : { log("ConditionalExpression"); }
{
	LogicalORExpression() ( <QUESTION> AssignmentExpression() <COLON> AssignmentExpression() )*
//	LogicalORExpression() |
//	LogicalORExpression() <QUESTION> AssignmentExpression() <COLON> AssignmentExpression()
}

public void ConditionalExpressionNoIn() : { log("ConditionalExpressionNoIn"); }
{
	LogicalORExpressionNoIn() ( <QUESTION> AssignmentExpressionNoIn() <COLON> AssignmentExpressionNoIn() )*
//	LogicalORExpressionNoIn() |
//	LogicalORExpressionNoIn() <QUESTION> AssignmentExpressionNoIn() <COLON> AssignmentExpressionNoIn()
}

public void AssignmentExpression() : { log("AssignmentExpression"); }
{
	ConditionalExpression() |
	LeftHandSideExpression() AssignmentOperator() AssignmentExpression()
}

public void AssignmentExpressionNoIn() : { log("AssignmentExpressionNoIn"); }
{
	ConditionalExpressionNoIn() |
	LeftHandSideExpression() AssignmentOperator() AssignmentExpressionNoIn()
}

public void AssignmentOperator() : { log("AssignmentOperator"); }
{
	<ASSIGN> |
	<MULT_ASSIGN> |
	<DIV_ASSIGN> |
	<MOD_ASSIGN> |
	<PLUS_ASSIGN> |
	<MINUS_ASSIGN> |
	<LSHIFT_ASSIGN> |
	<RSHIFT_ASSIGN> |
	<URSHIFT_ASSIGN> |
	<BAND_ASSIGN> |
	<XOR_ASSIGN> |
	<BOR_ASSIGN>
}

public void Expression() : { log("Expression"); }
{
	AssignmentExpression() ( <COMMA> AssignmentExpression() )*
}

public void ExpressionNoIn() : { log("ExpressionNoIn"); }
{
	AssignmentExpressionNoIn() ( <COMMA> AssignmentExpressionNoIn() )*
}



/*
 * Statements
 */

public void Statement() : { log("Statement"); }
{
	Block() |
	VariableStatement() |
	EmptyStatement() |
	ExpressionStatement() |
	IfStatement() |
	IterationStatement() |
	ContinueStatement() |
	BreakStatement() |
	ReturnStatement() |
	WithStatement() |
	LabelledStatement() |
	SwitchStatement() |
	ThrowStatement() |
	TryStatement()
}

public void Block() : { log("Block"); }
{
	<LBRACE> ( StatementList() )? <RBRACE>
}

public void StatementList() : { log("StatementList"); }
{
	( Statement() )+
}

public void VariableStatement() : { log("VariableStatement"); }
{
	<VAR> VariableDeclarationList() <SEMICOLON>
}

public void VariableDeclarationList() : { log("VariableDeclarationList"); }
{
	VariableDeclaration() ( <COMMA> VariableDeclaration() )* 
}

public void VariableDeclarationListNoIn() : { log("VariableDeclarationListNoIn"); }
{
	VariableDeclarationNoIn() ( <COMMA> VariableDeclarationNoIn() ) *
}

public void VariableDeclaration() : { log("VariableDeclaration"); }
{
	Identifier() (Initializer())?
}

public void VariableDeclarationNoIn() : { log("VariableDeclarationNoIn"); }
{
	Identifier() (InitializerNoIn())?
}

public void Initializer() : { log("Initializer"); }
{
	<ASSIGN> AssignmentExpression()
}

public void InitializerNoIn() : { log("InitializerNoIn"); }
{
	<ASSIGN> AssignmentExpressionNoIn()
}

public void EmptyStatement() : { log("EmptyStatement"); }
{
	<SEMICOLON>
}

public void ExpressionStatement() : { log("ExpressionStatement"); }
{
	LOOKAHEAD ( { getToken(1).kind != LBRACE && 
					getToken(1).kind != COMMA &&
					getToken(1).kind != FUNCTION  } )
	Expression() <SEMICOLON>
}

public void IfStatement() : { log("IfStatement"); }
{
	<IF> <LPAREN> Expression() <RPAREN> Statement() <ELSE> Statement() |
	<IF> <LPAREN> Expression() <RPAREN> Statement()
}

public void IterationStatement() : { log("IterationStatement"); }
{
	<DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON> |
	<WHILE> <LPAREN> Expression() <RPAREN> Statement() |
	<FOR> <LPAREN> (ExpressionNoIn())? <SEMICOLON> (Expression())? <SEMICOLON> (Expression())? <RPAREN> Statement() |
	<FOR> <LPAREN> <VAR> VariableDeclarationListNoIn() <SEMICOLON> (Expression())? <SEMICOLON> (Expression())? <RPAREN> Statement() |
	<FOR> <LPAREN> LeftHandSideExpression() <IN> Expression() <RPAREN> Statement() |
	<FOR> <LPAREN> <VAR> LeftHandSideExpression() <IN> Expression() <RPAREN> Statement()
}

public void ContinueStatement() : { log("ContinueStatement"); }
{
	<CONTINUE> (Identifier())? <SEMICOLON>
}

public void BreakStatement() : { log("BreakStatement"); }
{
	<BREAK> (Identifier())? <SEMICOLON>
}

public void ReturnStatement() : { log("ReturnStatement"); }
{
	<RETURN> (Identifier())? <SEMICOLON>
}

public void WithStatement() : { log("WithStatement"); }
{
	<WITH> <LPAREN> Expression() <LPAREN> Statement()
}

public void SwitchStatement() : { log("SwitchStatement"); }
{
	<SWITCH> <LPAREN> Expression() <RPAREN> CaseBlock()
}

public void CaseBlock() : { log("CaseBlock"); }
{
	<LBRACE> (CaseClauses())? <RBRACE> |
	<LBRACE> (CaseClauses())? DefaultClause() (CaseClauses())? <RBRACE>
}

public void CaseClauses() : { log("CaseClauses"); }
{
	( CaseClause() )+
}

public void CaseClause() : { log("CaseClause"); }
{
	<CASE> Expression() <COLON> (StatementList())?
}

public void DefaultClause() : { log("DefaultClause"); }
{
	<_DEFAULT> <COLON> (StatementList())?
}

public void LabelledStatement() : { log("LabelledStatement"); }
{
	Identifier() <COLON> Statement()
}

public void ThrowStatement() : { log("ThrowStatement"); }
{
	<THROW> Expression() <SEMICOLON>
}

public void TryStatement() : { log("TryStatement"); }
{
	<TRY> Block() Catch() |
	<TRY> Block() Finally() |
	<TRY> Block() Catch() Finally()
}

public void Catch() : { log("Catch"); }
{
	<CATCH> <LPAREN> Identifier() <RPAREN> Block()
}

public void Finally() : { log("Finally"); }
{
	<FINALLY> Block()
}


/*
 * Functions and Programs
 */

public void FunctionDeclaration() : { log("FunctionDeclaration"); }
{
	<FUNCTION> Identifier() <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FunctionExpression() : { log("FunctionExpression"); }
{
	<FUNCTION> (Identifier())? <LPAREN> (FormalParameterList())? <RPAREN> <LBRACE> FunctionBody() <RBRACE>
}

public void FormalParameterList() : { log("FormalParameterList"); }
{
	Identifier() ( <COMMA> Identifier() )*
}

public void FunctionBody() : { log("FunctionBody"); }
{
	SourceElements()
}

public void	Program() : { log("Program"); }
{
	SourceElements()
}

public void SourceElements() : { log("SourceElements"); }
{
	( SourceElement() )+
}

public void SourceElement() : { log("SourceElement"); }
{
	Statement() |
	FunctionDeclaration()
}




















/*

public void IfStatement() : { System.out.println("if statement"); }
{
	<IF> PrimaryExpression() Block()
}

public void Block() : { System.out.println("block"); }
{
	<LBRACE> Statements() <RBRACE> |
	Statement()
}

public void Assignment() : { System.out.println("assignment"); }
{
	Identifier() <ASSIGN> Expression() <SEMICOLON>
}

public void VariableDeclaration() : { System.out.println("variable declaration"); }
{
	<VAR> <IDENTIFIER> (VariableDeclarationCont())? (<ASSIGN> Expression())? <SEMICOLON>
}

public void VariableDeclarationCont() : { System.out.println("variable declaration cont"); }
{
	<COMMA> <IDENTIFIER> (VariableDeclarationCont())?
}

public void FunctionDeclaration() : { System.out.println("function declaration"); }
{
	<FUNCTION> <IDENTIFIER> <LPAREN> ParameterList() <RPAREN> <LBRACE> Statements() <RBRACE>
}

public void ParameterList() : { System.out.println("parameter list"); }
{
	<IDENTIFIER> (ParameterListCont())?	
}

public void ParameterListCont() : { System.out.println("parameter list cont"); }
{
	<COMMA> <IDENTIFIER> (ParameterListCont())?
}

public void Return() : { System.out.println("return"); }
{
	<RETURN> (Expression())? <SEMICOLON>
}

public void PrimaryExpression() : { System.out.println("primary expression"); }
{
	<THIS> |
	Identifier() |
	// Literal() |
	// ArrayLiteral() |
	// ObjectLiteral() |
	<LPAREN> Expression() <RPAREN>
}


public void Expression() : { System.out.println("expression"); }
{
	Identifier() |
	Literal()
}

public void Identifier() : { System.out.println("identifier"); }
{
	<IDENTIFIER>
}

public void Literal() : { System.out.println("literal"); }
{
	NullLiteral() |
//	BooleanLiteral()  |
//	NumericLiteral() |
//	StringLiteral() 
}

public void NullLiteral() : { System.out.println("null"); }
{
	<NULL>
}

public void BooleanLiteral() : { System.out.println("boolean"); }
{
	<TRUE> | 
	<FALSE>
}

*/